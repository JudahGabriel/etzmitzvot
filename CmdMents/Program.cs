using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.IO;
using System.Diagnostics;

namespace CmdMents
{
    class Program
    {
        const string quote = "\"";
        static IEnumerable<Type> commandmentTypes;

        /// <summary>
        /// Generates the internal graph, outputs it for rendering, and displays the rendered image.
        /// </summary>
        /// <param name="args">Unused.</param>
        static void Main(string[] args)
        {
            commandmentTypes = (from type in typeof(CommandmentBase).Assembly.GetTypes()
                                where typeof(CommandmentBase).IsAssignableFrom(type) && !type.IsAbstract
                                select type).ToArray();

            var builder = new StringBuilder();
            foreach (var item in BuildCommandmentsHierarchy())
            {
                builder.AppendLine(item);
                Console.WriteLine(item);
            }

            var imagePath = CreateImageFromDotInstructions(builder.ToString());
            Process.Start(imagePath);
        }

        /// <summary>
        /// Writes the image generated by the given graphing instructions to a file.
        /// </summary>
        /// <param name="dotInstructions">The <see cref="string"/> containing the DOT instructions that generate the desired graph.</param>
        /// <returns>The name of the image file that was output.</returns>
        private static string CreateImageFromDotInstructions(string dotInstructions)
        {
            using (var process = new Process())
            {
                var isX64 = IntPtr.Size == 8;

                var programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
                if (isX64) programFiles += " (x86)";                // Always grab the 32-bit version
                var graphVizPath = Path.Combine(programFiles, @"Graphviz2.24\bin\dot.exe");

                process.StartInfo.FileName = graphVizPath;
                process.StartInfo.Arguments = "-Tpng -Gcharset=latin1";
                process.StartInfo.WindowStyle = ProcessWindowStyle.Minimized;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardInput = true;
                process.StartInfo.UseShellExecute = false;
                process.Start();

                byte[] buffer = new byte[4096];
                var standardOutput = process.StandardOutput.BaseStream;
                using (var imageOutputStream = File.Open("CmdMents.png", FileMode.Create))
                {
                    AsyncCallback callback = null;
                    IAsyncResult asyncResult = null;
                    var evt = new System.Threading.AutoResetEvent(false);
                    callback = result =>
                    {
                        int numberOfBytesRead = standardOutput.EndRead(result);
                        imageOutputStream.Write(buffer, 0, numberOfBytesRead);

                        if (numberOfBytesRead > 0)
                        {
                            // Read next bytes.   
                            asyncResult = standardOutput.BeginRead(buffer, 0, buffer.Length, callback, null);
                        }
                        else
                        {
                            // Signal that we're done.
                            evt.Set();
                        }
                    };
                    asyncResult = standardOutput.BeginRead(buffer, 0, buffer.Length, callback, null);
                    process.StandardInput.Write(dotInstructions);
                    process.StandardInput.Close();
                    standardOutput.Flush();
                    process.WaitForExit();
                    evt.WaitOne();
                }
            }
            return "CmdMents.png";
        }

        /// <summary>
        /// Emits the DOT instructions to render the entire graph, 
        /// based on subclassing metadata available through reflection.
        /// </summary>
        /// <returns>An <see cref="IEnumerable<string>"/> containing the emitted lines.</returns>
        private static IEnumerable<string> BuildCommandmentsHierarchy()
        {
            yield return (" digraph Commandments {");
            yield return "ratio = fill";
            yield return "node[style = filled]";

            foreach (var line in BuildNodeTree(typeof(CommandmentBase)))
            {
                yield return line + ";";
            }

            foreach (var line in BuildDescendantTree(typeof(CommandmentBase)))
            {
                yield return line + ";";
            }

            yield return "}";
        }

        /// <summary>
        /// Emits the DOT instructions to render the current subtree of the graph, 
        /// based on subclassing metadata available through reflection.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> representing the subtree to emit a graph for.</param>
        /// <returns>An <see cref="IEnumerable&lt;string&gt;"/> containing the emitted lines.</returns>
        /// <remarks>Does not emit the definitions of nodes, but only their relationships.
        /// Use <seealso cref="BuildNodeTree"/> to emit node definitions.</remarks>
        private static IEnumerable<string> BuildDescendantTree(Type type)
        {
            foreach (var derived in GetAllTypesDerivingFrom(type))
            {
                var edgeLine = BuildDescendantEdgeLineFrom(derived);
                if (!string.IsNullOrEmpty(edgeLine))
                {
                    yield return edgeLine;
                }

                foreach (var childOfDerivedString in BuildDescendantTree(derived))
                {
                    yield return childOfDerivedString;
                }
            }
        }

        /// <summary>
        /// Emits a single parent -> descendant directed edge.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> for which to generate a directed edge.</param>
        /// <returns>The DOT instruction line corresponding to a parent -> descendant relationship.</returns>
        /// <remarks>Does not emit the definition of either node.
        /// Use <seealso cref="BuildNodeLineFrom"/> to emit node definitions.</remarks>
        private static string BuildDescendantEdgeLineFrom(Type type)
        {
            var instance = (CommandmentBase)Activator.CreateInstance(type);
            return instance.GetDotHierarchyString();
        }

        /// <summary>
        /// Emits the DOT instructions to render the current subtree of the graph, 
        /// based on subclassing metadata available through reflection.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> representing the subtree to emit a graph for.</param>
        /// <returns>An <see cref="IEnumerable&lt;string&gt;"/> containing the emitted lines.</returns>
        /// <remarks>Does not emit the relationships between nodes, but only their definitions.
        /// Use <seealso cref="BuildDescendantTree"/> to emit node definitions.</remarks>
        private static IEnumerable<string> BuildNodeTree(Type type)
        {
            foreach (var derived in GetAllTypesDerivingFrom(type))
            {
                yield return BuildNodeLineFrom(derived);
                foreach (var nodeDefinitionString in BuildNodeTree(derived))
                {
                    yield return nodeDefinitionString;
                }
            }
        }

        /// <summary>
        /// Emits a single node definition.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> for which to generate a directed edge.</param>
        /// <returns>The DOT instruction line corresponding to a parent -> descendant relationship.</returns>
        /// <remarks>Does not emit the definition of either node.
        /// Use <seealso cref="BuildNodeLineFrom"/> to emit node definitions.</remarks>
        private static string BuildNodeLineFrom(Type type)
        {
            var instance = (CommandmentBase)Activator.CreateInstance(type);
            return instance.GetDotNodeDefinitionString();
        }

        /// <summary>
        /// Returns all descendants of a given commandment.
        /// </summary>
        /// <param name="t">The parent <see cref="Type"/>.</param>
        /// <returns>All subclasses of <paramref name="t"/> from the cached types collection.</returns>
        static IEnumerable<Type> GetAllTypesDerivingFrom(Type t)
        {
            return from type in commandmentTypes
                   where type.BaseType == t
                   select type;
        }
    }
}
